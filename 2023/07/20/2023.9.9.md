# CCF CSP 2023.5

## 一.国际象棋局面出现次数问题（田地丈量问题）

解题思路：把每个棋盘的棋子保存到字符数组中，然后判断这个字符串在map中是否出现过，若出现过，则次数加一，否则记录该字符串的出现次数为1。

```c++
#include <bits/stdc++.h>
using namespace std;
int n;
char pieces[64];//用于存储每个输入的字符
map<string, int> status_map;//声明一个关联容器，用于存储字符串及其出现次数
int main()
{
    cin >> n;
    for (int i = 0; i < n; i++)//循环读取n个字符串序列
    {
        for (int j = 0; j < 64; j++) 
            cin >> pieces[j];//从标准输入读取每个字符，每个局面最多读取64个字符
        if (status_map.count(pieces)) 
            status_map[pieces] ++;//该局面已经存在，增加出现次数
        else 
            status_map[pieces] = 1;//不存在，次数设置为1
        cout << status_map[pieces] << endl;
    }
    return 0;
}
```

## **知识点**

①<u>关联容器</u>

```c++
map<string, int> status_map;//声明一个关联容器
status_map["active"] = 1;     // 将字符串"active"与整数1关联起来
status_map["inactive"] = 0;   // 将字符串"inactive"与整数0关联起来

int status = status_map["active"]; // 通过键"active"获取关联的整数值，status现在等于1
```

②<u>status_map.count(pieces)</u></u>

是用于检查 `pieces` 在 `status_map` 中是否存在的表达式。

- 如果 `pieces` 在 `status_map` 中存在，`status_map.count(pieces)` 返回 1，表示存在一个与 `pieces` 关联的元素。
- 如果 `pieces` 在 `status_map` 中不存在，`status_map.count(pieces)` 返回 0，表示没有与 `pieces` 关联的元素。

## 二.矩阵乘法

规则：假设有两个矩阵 A 和 B，<u>它们可以相乘的前提是，A 的列数必须等于 B 的行数</u>。如果 A 是一个 m×n 的矩阵（m 行 n 列），而 B 是一个 n×p 的矩阵（n 行 p 列），那么它们的乘积 AB 是一个 m×p 的矩阵（m 行 p 列）。

因为AB≠BA，所以矩阵乘法不满足交换律。

计算方法：

C(i, j) = A(i,1) * B(1,j) + A(i,2) * B(2,j) + ... + A(i,n) * B(n,j)

### 问题描述

为了方便计算，顿顿同学将 Softmax 简化为了点乘一个大小为 n 的一维向量 W：
(W⋅(Q×KT))×V
点乘即对应位相乘，记 W(i) 为向量 W 的第 i 个元素，即将 (Q×KT) 第 i 行中的每个元素都与 W(i) 相乘。

现给出矩阵 Q、K 和 V 和向量 W，试计算顿顿按简化的算式计算的结果。

<u>解题思路：</u>重点在于时间复杂度，如果先算QK矩阵相乘，会得到n*n的矩阵，会造成超时，所以要先计算后面两个矩阵，即：先计算K矩阵的转置与V矩阵的乘积，然后再与Q矩阵相乘，最后再与W相乘。

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;//创建新的类型别名，用“LL”代替“long long”，通常表示非常大的整数
const int N = 10010, D = 30;
LL tmp[D][D], ans[N][N];//tmp是一个临时矩阵，用于存储K的转置和V矩阵的乘积结果；ans用于存储最终的结果
int n, d;
int Q[N][D], K[N][D], V[N][D], W[N];
int main()
{
    cin >> n >> d;
    //Q
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= d; j ++)
            cin >> Q[i][j];
    //K
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= d; j ++)
            cin >> K[i][j];
    //V
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= d; j ++)
            cin >> V[i][j];
    //W
    for (int i = 1; i <= n; i ++) cin >> W[i];
    

	// 计算 K的转置 * V = tmp
	for (int i = 1; i <= d; i ++)
	    for (int j = 1; j <= d; j ++)
	        for (int k = 1; k <= n; k ++)
	            tmp[i][j] += K[k][i] * V[k][j];
	            
	// 计算 Q * tmp = ans
	for (int i = 1; i <= n; i ++)
	    for (int j = 1; j <= d; j ++)
	    {
	        for (int k = 1; k <= d; k ++)
	            ans[i][j] += Q[i][k] * tmp[k][j];
	        ans[i][j] *= (LL) W[i];
	    }
	    
	for (int i = 1; i <= n; i ++)
	{
	    for (int j = 1; j <= d; j ++)
	        cout << ans[i][j] << " ";
	    cout << endl;
	}
	return 0;

}
```

## 三.解压缩

<u>题目理解</u>： 给你一段压缩过的代码，可以拆分为引导域和数据域，引导域决定了解压缩后的数据长度，数据域也是可以分段的，每一段由其第一个字节的最低两位决定，若为00，则是字面量，若为01或10，则为回溯引用。输出解压缩后的数据，8字节为一行，最后一行允许不到8个字节。



<u>思路分析</u>：  由于要多次读取字节，所以最好封装一个函数来 读取字节 ，记录当前读到的位置。由于要进行小端序调整字符串，可以考虑封装一个函数来 按小端序调整字符串 。由于01和10结尾都要回溯引用，也可以封装一个函数来 填充字符串 。由于用字节处理太麻烦了，可以使用 stoi()——有符号整型 或者 stoul——无符号整型 来进行进制转换。

直接看子任务，进行功能简化。

输入：输入压缩的数据流，s个字节字符（2s个数字或者字母a到f）

按照输入格式的说明，读入输入数据存储到（待解压）字符串中。

定位数据域：定位数据域中的每一个元素（只处理元素是字面量的情况）

1：字面量包含的字节个数小于等于60

2：字面量包含的字节个数大于60

将每个字面量元素中的数据，依次合并到输出（解压）字符串中。

被压缩的数据格式分为两部分：引导域和数据域

$\textcolor{red}{引导域}$:除了最后一个字节的最高位为0，其余字节的最高位为1.

$\textcolor{red}{数据域}$：保存了被压缩后的数据，是连续存储的元素的序列。每个元素的第一个字节的最低两位表示了元素的类型。

当最低两位为0时，表示这是一个字面量。

①如果字面量包含的字节个数为l，且l≤60，那么第一个字节的高6位表示（l-1），随后的l字节即为字面量所包含的原始字节。

②如果l＞60，第一个字节的高六位存储的值为60，61，62或63时，分别表示（l-1）用1，2，3或4个字节表示，存储于第一个字节的后面，随后的l个字节即为字面量所包含的原始字节。

$\textcolor{red}{然后模拟过程}$

## $\textcolor{green}{补充：将16进制字符串转换成10进制}$

在c++中可以使用strtol函数。

long int strtol(const char* str, char** endptr, int base);

- `str` 是要进行转换的字符串。
- `endptr` 是一个指向字符指针的指针，用于存储在转换过程中停止的位置。这是一个可选参数，你可以将其设置为`NULL`，如果你不需要知道停止位置。
- `base` 表示要使用的进制，通常是10进制，但也可以是其他进制，如16进制。如果不指定进制，函数会根据字符串的前缀来确定。

简单示例：

```c++
#include <iostream>
#include <cstdlib>

int main() {
    const char* str = "12345";
    char* endptr;
    

    long int result = strtol(str, &endptr, 10);
    
    if (endptr == str) {
        std::cout << "无效的转换" << std::endl;
    } else {
        std::cout << "转换结果为: " << result << std::endl;
        std::cout << "未转换部分: " << endptr << std::endl;
    }
    
    return 0;

}
```





